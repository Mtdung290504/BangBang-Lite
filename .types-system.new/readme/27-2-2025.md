# DSL Design Notes

> Ghi chú các quyết định thiết kế và hướng tư duy đã được thống nhất.

---

## 1. `DamageType` → `reduction-policy`

**Vấn đề:** `DamageType = 'true' | 'physical' | 'energy'` đang mô tả _nguồn gốc_ sát thương, trong khi thứ thực sự quan trọng với engine là **công thức tính giảm dame**.

**Hướng đi:** Đổi tư duy sang `reduction-policy` — "dame này bị giảm theo công thức nào?".

```typescript
// Trước — trói vào ngữ nghĩa nguồn gốc
export type DamageType = 'true' | 'physical' | 'energy';

// Sau — mô tả đúng bản chất
export type DamageReductionPolicy =
	| 'bypass-armor' // true damage, không giảm
	| 'use-armor' // tính theo giáp vật lý
	| 'use-shield'; // tính theo kháng năng lượng
```

**Lợi ích:** Khi thêm mechanic mới như "xuyên % giáp" hay "giảm theo HP mất" — chỉ thêm policy mới, không đụng vào logic cũ.

```typescript
// Ví dụ mở rộng về sau không cần đụng code cũ
| { type: 'partial-bypass'; penetration: ValueWithUnit } // xuyên một phần giáp
| { type: 'hp-scaling'; ratio: ValueWithUnit }           // scale theo HP mất
```

---

## 2. Phase không cần generic

**Vấn đề:** `SkillManifest<Phases extends number[]>` truyền generic xuống mọi skill slot, buộc tất cả skill dùng chung 1 tập phase. s1 và s2 không thể có phase set khác nhau.

**Hướng đi:** Phase là runtime state label. Dùng `string` key thay vì `number` để có ngữ nghĩa rõ hơn, bỏ generic hoàn toàn.

```typescript
// Trước
type PhasedSkill<Phases extends number[]> = {
  type: 'phased';
  'phases-definition': Record<Phases[number], SingleSkill>;
};
export interface SkillManifest<Phases extends number[]> { ... }

// Sau
type PhasedSkill = {
  type: 'phased';
  'phases-definition': Record<string, SingleSkill>;
  // Ví dụ: { 'normal': ..., 'rage': ..., 'awakened': ... }
  // Hoặc đánh số vẫn được: { '0': ..., '1': ..., '2': ... }
};

// SkillEntry: đơn hoặc phased, mỗi slot tự quyết định
export type SkillEntry = SingleSkill | PhasedSkill;

export interface SkillManifest {
  passive: PassiveSkillEntry[];
  'normal-attack': SkillEntry;
  s1: SkillEntry;   // có thể phased 2 phase
  s2: SkillEntry;   // có thể phased 3 phase khác nhau hoàn toàn
  ultimate: SkillEntry;
}
```

---

## 3. Condition System

**Vấn đề:** Passive skill đang có `conditions?: []` bỏ trống. Effect không có condition nào. Cần hệ thống thống nhất.

**Nguyên tắc thiết kế:** Condition là _predicate trên game state_ — lấy một attribute, so sánh với ngưỡng. Dùng cùng tư duy `value-from` đã có sẵn. Threshold gộp vào template literal string như `ValueWithUnit`.

```typescript
type ConditionOp = '>' | '<' | '>=' | '<=' | '=';
type ConditionThreshold = `${ConditionOp}${number}${'%' | 'u'}`;
// Ví dụ: '>30%', '<=500u', '=3u'

type Condition = {
	'value-from': {
		attribute: TankStatValueKey | 'enemy-nearby' | 'ally-nearby' | 'current-stack';
		of?: 'self' | 'target';
	};
	threshold: ConditionThreshold;
};
```

**Condition gắn vào `ImpactAction`** — tư duy "if A thì áp effect A, if B thì áp effect B":

```typescript
type ImpactAction = {
  'affected-faction'?: Faction[];
  'condition'?: Condition;       // <- thêm vào đây
  'target-effect'?: ...
  'self-action'?: ...
};
```

**Ví dụ:**

```typescript
// Nếu target HP < 30% thì gây thêm dame
impact: {
  actions: [
    {
      // Damage bình thường — không cần condition
      'target-effect': { action: '@apply:effect', manifest: { ... } }
    },
    {
      // Thêm damage nếu target HP thấp
      condition: { 'value-from': { attribute: 'current-HP', of: 'target' }, threshold: '<30%' },
      'target-effect': {
        action: '@apply:effect',
        manifest: {
          impacts: {
            'on-start': {
              action: '@apply:dealt-damage',
              'value-from': { attribute: 'attack-power', value: '50%' },
            }
          }
        }
      }
    }
  ]
}
```

Muốn logic phức tạp hơn → tách thành nhiều `ImpactAction` độc lập, không lồng condition vào nhau.

---

## 4. Sensor Entity Pattern

**Tư duy cốt lõi: đừng bị ngữ nghĩa trói buộc — nhìn vào mảnh ghép sẵn có.**

`Renderable` là optional, `Movable` là optional — impactor hoàn toàn có thể không có visual, không có movement. Collision detection sẵn có trở thành **query engine**.

**Pattern:** Tạo impactor "tàng hình" đứng im, dùng collider để _đọc_ game state thông qua va chạm.

**Ví dụ: Stack tăng theo số địch xung quanh**

Thay vì extend type system để hỗ trợ "dynamic stack", dùng sensor entity:

```typescript
// Passive skill tạo sensor mỗi frame
{
  action: '@create-entity',
  // Không có visual = tàng hình
  // Không có movement = đứng im
  from: 'self-pos',
  collider: {
    shape: { type: 'circle', size: { radius: 300 } }, // phạm vi detect
    pierce: ['architecture', 'self', 'ally'],          // chỉ trigger khi chạm enemy
  },
  impact: {
    interval: 0.016, // check mỗi frame
    actions: {
      'affected-faction': ['enemy'],
      'self-action': {
        // Mỗi enemy trong vùng = +1 stack lên caster
        action: '@apply:effect',
        manifest: {
          name: 'enemy-count-stack',
          duration: 0.016, // tự reset mỗi frame
          impacts: { /* behavior tương ứng stack */ }
        }
      }
    }
  }
}
```

**Lợi ích:** Tự động handle phạm vi (radius), faction filter, đếm số lượng — không cần thêm 1 dòng type mới. Muốn đổi phạm vi? Đổi `radius`. Muốn đếm ally? Đổi `pierce`.

---

## 5. Condition: Trigger vs Stat Modifier

Hai loại condition khác nhau về bản chất, không trộn lẫn:

**Trigger condition** — "khi nào thì làm gì đó" (one-shot)

Ví dụ: "Khi HP xuống dưới 30%, tăng tốc độ" → Dùng **sensor entity** với collider detect trạng thái HP, không cần condition system.

```typescript
// Sensor check HP mỗi frame, tự trigger khi thỏa điều kiện
{
  action: '@create-entity',
  from: 'self-pos',
  impact: {
    interval: 0.1,
    actions: {
      condition: { 'value-from': { attribute: 'current-HP', of: 'self' }, threshold: '<30%' },
      'self-action': {
        action: '@apply:effect',
        manifest: { /* buff tăng tốc */ }
      }
    }
  }
}
```

**Stat modifier condition** — "buff này có hiệu lực khi nào" (continuous, real-time)

Ví dụ: "Tăng tốc 20% nhưng chỉ khi đang một mình (không có ally xung quanh)" → Condition gắn vào `modify-stats`, engine check liên tục.
Note nữa: SKILL PHẢI ĐƯỢC TRẢI RA, KHÔNG ĐƯỢC THUỘC VỀ 1 INSTANCE TANK. Vì 2 vấn đề, 1 là tái sử dụng bộ skill giữa các tank trùng nhau, 2 là để kakashi copy skill, nếu ngu ngốc lưu skill trên instance -> bug. Instance tank chứa string key để lấy skill

```typescript
'modify-stats': {
  'value-from': { attribute: 'movement-speed', value: '20%' },
  condition: {
    'value-from': { attribute: 'ally-nearby', of: 'self' },
    threshold: '=0u' // không có ally nào xung quanh
  }
}
```

Sensor entity không giải quyết được case này vì buff cần _maintain_ trạng thái liên tục, không phải trigger one-shot.
