# Code Scan Results

Thời gian quét: 09:45:41 5/2/2026
Tổng số file: 24
Tool scanner: index.js (đã bỏ qua)

---

dsl/combat/effect.type-components.ts:

```typescript
import { ValueWithUnit } from '../.types';
import { TankStatValueKey } from '../entity/tank/.enums';

export interface StatValue<T extends TankStatValueKey = TankStatValueKey> {
	'value-from': {
		attribute: T;
		value: ValueWithUnit;

		/** Mặc định: `target` */
		of?: 'self' | 'target';
	};
}
```

dsl/combat/props.type-components.ts:

```typescript
export interface Bounceable {
	bounce?: {
		limit: number;
		'bounce-range': number;
	};
}

export interface Pursuitable {
	/**Đạn có đuổi mục tiêu hay không */
	pursuit?: true;
}
```

dsl/combat/state.type-components.ts:

```typescript
import { ImpactAction } from '../entity/skill/actions/.types';
import { Renderable } from './visual.type-components';

export interface LimitedDuration {
	/**
	 * Thời gian kéo dài
	 * - Đơn vị: s
	 * - Mặc định: `Infinity`
	 */
	duration?: number;
}

export interface Impactable {
	impact: {
		/**
		 * Danh sách các xử lý khi trúng đích, mở rộng hết cỡ để cấu hình xử lý khác nhau tùy vào mục trúng đòn
		 */
		actions: ImpactAction[];

		/**
		 * Impact diễn ra nhiều lần theo interval, đơn vị: giây
		 * - Nếu khai báo, skill impact nhiều lần theo interval đó
		 * - Nếu không khai báo thì chỉ impact 1 lần
		 */
		interval?: number;
	} & Renderable; // Hiệu ứng khi va chạm
}
```

dsl/combat/status.type-components.ts:

```typescript
import { ImpactAction } from '../entity/skill/actions/.types';
import { Impactable, LimitedDuration } from './state.type-components';
import { Renderable, VisualManifest } from './visual.type-components';

export interface EffectManifest extends Renderable, LimitedDuration {
	/** Name để nhận diện effect dùng cho stack và hiển thị */
	name?: string;

	/** Mô tả hiển thị */
	description?: string;

	/**
	 * Icon hiển thị
	 * @override
	 */
	visual?: VisualManifest;

	/**
	 * Thời gian tồn tại.\
	 * Cơ chế: Bồi thêm stack -> Reset thời gian về ban đầu
	 * Mặc định: 0 (VD gây damage bình thường, không có thêm gì)
	 * @override
	 */
	duration?: number;

	/**
	 * Impact diễn ra nhiều lần theo interval, đơn vị: giây
	 * - Nếu khai báo, skill impact nhiều lần theo interval đó
	 * - Nếu không khai báo thì chỉ impact 1 lần
	 */
	// interval?: number;

	/**
	 * Định nghĩa hành vi cho từng stack. Quy định luôn số stack tối đa
	 *
	 * - Ví dụ [stack1, stack2, stack...]
	 * - action: Khai báo hành động đốt, hoặc áp effect như làm chậm
	 * - interval: tần suất kích hoạt action
	 * - on-enter: khi đạt đến stack này sẽ kích hoạt action gì đó
	 * - visual: hiệu ứng effect, ví dụ lửa tầng 1 khác tầng 2, 3, 4
	 */
	impacts: (Omit<Impactable['impact'], 'interval'> & { 'on-enter'?: (ImpactAction | 'clear')[] })[];
}

const test: EffectManifest = {
	name: 'starlord-passive',
	description: 'Địch giảm tốc và chịu ST, bản thân tăng tốc công',
	duration: 2,
	visual: { sprite: { key: 'starlord-burn' } },
	impacts: [1, 2, 3, 4].map((stack) => ({
		visual: { sprite: { key: `burn-effect-stack:${stack}` } },
		actions: [
			{
				// Không đốt trụ được nên chỉ enemy
				'affected-faction': ['enemy'],

				// Tăng tốc đánh bản thân 5% mỗi tầng
				'self-action': [
					{
						action: '@apply:modify-stat',
						'value-from': { attribute: 'fire-rate', of: 'self', value: `${5 * stack}%` },
					},
				],

				// Địch giảm tốc chạy 10% và chịu 20% tấn công/s mỗi tầng
				'target-effect': [
					{
						action: '@apply:modify-stat',
						'value-from': { attribute: 'movement-speed', of: 'target', value: `${10 * stack}%` },
					},
					{
						action: '@apply:dealt-damage',
						'value-from': { attribute: 'attack-power', of: 'self', value: `${20 * stack}%` },
					},
				],
			},
		],
	})),
};
```

dsl/combat/visual.enums.ts:

```typescript
export type DefaultNormalAttackSprite = 'normal-attack';
export type SpriteKey = DefaultNormalAttackSprite | (string & {});
```

dsl/combat/visual.type-components.ts:

```typescript
import { SpriteDeclaration } from './visual.types';

export interface VisualManifest {
	/**Khai báo sprite */
	sprite: SpriteDeclaration;

	/**Góc xoay hình (degrees) mặc định là 0 */
	rotate?: number;

	/**Thời gian tồn tại effect, mặc định: 0 - Tức hiệu ứng sẽ biến mất ngay khi entity biến mất */
	duration?: number;
}

export interface Renderable {
	/**Không khai báo = invisible (dùng cho skill ẩn hoặc chỉ logic) */
	visual?: VisualManifest;
}

export interface TextVisual {
	/**
	 * Quyết định hiển thị số bay lên thẳng hay chéo.
	 * Công thức tính góc dự kiến: 90 + `text-delta-angle` * 15
	 * Mặc định: `0` (bay thẳng lên: 90 + 0 * 15)
	 */
	'text-delta-angle'?: -1 | 0 | 1;
}
```

dsl/combat/visual.types.ts:

```typescript
import { SpriteKey } from './visual.enums';

/** Khai báo sprite để hiển thị */
export type SpriteDeclaration = {
	/** Key của sprite trong asset manifest */
	key: SpriteKey;

	/** Ghi đè kích thước gốc của sprite (pixels). Không khai báo = dùng kích thước gốc */
	'display-size'?: { width: number; height: number };
};
```

dsl/entity/skill/actions/apply-effect.type-entities.ts:

```typescript
import { ActionType } from './.type-components';
import { StatValue } from '../../../combat/effect.type-components';
import { LimitedDuration } from '../../../combat/state.type-components';
import { TextVisual } from '../../../combat/visual.type-components';
import { DamageType } from '../../tank/.enums';
import { EffectManifest } from '../../../combat/status.type-components';

// Sửa HP và MP
type ModifyStats<ActionTypeName extends string> = ActionType<'apply', ActionTypeName> & StatValue & TextVisual;
export interface DealtDamage extends ModifyStats<'dealt-damage'> {
	/** Mặc định kế thừa từ tank */
	'damage-type'?: DamageType;

	/** Cờ để trừ damage trong một số trường hợp, ví dụ khi đạn nảy hay xuyên */
	'is-main-damage'?: boolean;
}
export interface RecoverHP extends ModifyStats<'recover-hp'> {}
export interface ModifyEnergy extends ModifyStats<'modify-energy'> {}

// Sửa phase
export interface ChangePhase extends ActionType<'apply', 'change-phase'>, LimitedDuration {
	method: 'next' | `to-phase:${number}`;
}

// Sửa các chỉ số khác như tốc chạy, tốc đánh, giáp,...
export interface ModifyStat extends ActionType<'apply', 'modify-stat'>, StatValue, LimitedDuration {}

export interface ApplyEffect extends ActionType<'apply', 'effect'> {
	effect: EffectManifest;
}

export interface ModifyCountdown {}

const t: ModifyStat = {
	action: '@apply:modify-stat',
	'value-from': { attribute: 'attack-power', of: 'self', value: '50%' },
	duration: 2,
};
```

dsl/entity/skill/actions/create-attack.type-entities.ts:

```typescript
import { ActionType, UseDirectionStrategy, UseUseTargetingStrategy } from './.type-components';
import { Bounceable, Pursuitable } from '../../../combat/props.type-components';
import { Impactable } from '../../../combat/state.type-components';
import { Renderable } from '../../../combat/visual.type-components';
import { Collidable } from '../../../physic/collider.type-conponents';
import { Movable } from '../../../physic/movement.type-components';
import { RequireInitPositionMethod } from '../../../physic/position.type-components';
import { LimitedDistance } from '../../../physic/range.type-components';

interface CreateImpactor
	extends Impactable, ActionType<'create-entity'>, LimitedDistance, Renderable, Collidable, Movable, Bounceable {}

/**
 * Note: Nếu muốn apply effect lên mình thì cần tạo hitbox mang effect lên mình tại chỗ
 */
export interface CreateNonContextImpactor
	extends CreateImpactor, UseDirectionStrategy, RequireInitPositionMethod<'mouse-pos' | 'self-pos' | 'target-pos'> {}

export interface CreateContextImpactor
	extends CreateImpactor, UseUseTargetingStrategy, RequireInitPositionMethod, Pursuitable {}
```

dsl/entity/skill/active.type-entities.ts:

```typescript
import type { ActionBased, SkillTiming } from './.type-components';
import { SkillTypeDef } from './.types';

/**
 * Skill cơ bản, dùng xong hồi chiêu, không có gì đặc biệt
 */
export type NormalSkill = SkillTiming & ActionBased & SkillTypeDef<'normal'>;

/**
 * Skill có tích lũy
 */
type StackedSkill = SkillTiming &
	ActionBased &
	SkillTypeDef<
		'stacked',
		{
			/** Số stack tối đa */
			'max-stack': 2 | 3 | 5;

			/** Thời gian hồi 1 stack, đơn vị: giây */
			'stack-time': number;
		}
	>;

/**
 * Skill nhiều giai đoạn
 */
type MultiStageSkill = SkillTiming &
	SkillTypeDef<
		'multi-stage',
		{
			/** Danh sách hành vi của các giai đoạn */
			stages: ActionBased[];

			/** Quy định giới hạn thời gian tồn tại của 1 giai đoạn, đơn vị: giây */
			timeout: number;
		}
	>;

// Các union dùng cho manifest
type SingleSkill = NormalSkill | StackedSkill | MultiStageSkill;

/**
 * Skill thay đổi hành vi theo phase (Trạng thái/Hệ)
 */
type PhasedSkill<Phases extends number[]> = {
	type: 'phased';

	/** Định nghĩa từng phase như 1 skill đơn */
	'phases-definition': Record<Phases[number], SingleSkill>;
};

/** Chuyển kiểu theo có phase hay skill */
export type SkillEntry<Phases extends number[]> = Phases extends [] ? SingleSkill : SingleSkill | PhasedSkill<Phases>;
```

dsl/entity/skill/context/casting-methods.type-components.ts:

```typescript
/**
 * @description
 * - Mô tả skill được tung ra bằng cách nào để làm indicator
 * - Không chỉ thế, còn giới hạn bớt context mà các action có thể sử dụng
 */

import { LimitedDistance } from '../../../physic/range.type-components';

/**
 * Skill người chơi khóa mục tiêu (Ví dụ: Q mất máu)
 */
export interface TargetedCast extends LimitedDistance {
	type: 'on-target';
}

/** Skill chọn vùng tung ra (Ví dụ: R Magneto) */
export interface AreaCast extends LimitedDistance {
	type: 'at-area';

	/** Không tác động đến logic game, chỉ hiển thị vòng tròn có d = size chỉ định */
	display?: { size: number };
}

/** Skill theo hướng (Ví dụ: E TV)*/
export interface DirectionCast extends LimitedDistance {
	type: 'in-direction';

	/** Không tác động đến logic game, chỉ hiển thị mũi tên có width = size chỉ định */
	display?: { size: number };
}

export type CastingMethod = TargetedCast | AreaCast | DirectionCast;
```

dsl/entity/skill/passive.type-entities.ts:

```typescript
import { TankEventActorsMap } from './context/.types';
import { AttackPowerStats, ShootingStats, SurvivalStats } from '../tank/.types';
import { ValueWithUnit } from '../../.types';

import { SkillTiming } from './.type-components';
import { SkillTypeDef } from './.types';

// Note sửa ActionBased thành chuyên biệt cho passive skill
// import { PassiveSkillAction } from '../actions/skill-actions';
type PassiveSkillAction = `Implement later:${string}`;

/**
 * Bị động kích hoạt theo event - Ví dụ Kirito
 */
type EventTriggeredPassive = SkillTiming &
	SkillTypeDef<
		'event-triggered',
		{
			/** Event nào sẽ trigger */
			'trigger-event': keyof TankEventActorsMap;

			/**
			 * Điều kiện để trigger (optional)
			 * - Ví dụ trigger khi chịu dame, mà chịu xong HP phải dưới 30% mới kích hoạt
			 */
			condition?: [];

			/** Hành động khi trigger */
			actions: PassiveSkillAction[];
		}
	>;

/**
 * Bị động kích hoạt định kỳ theo thời gian (countdown) - Ví dụ: Hồ lô, Khiên LLQ/Iron/Chop
 */
type PeriodicPassive = SkillTiming &
	SkillTypeDef<
		'periodic',
		{
			/** Hành động khi trigger */
			actions: PassiveSkillAction[];

			/** Điều kiện để có thể trigger (optional) */
			conditions?: [];

			// Còn rắc rối khi cần kiểu "Khiên vỡ mới CD", có khi tách thành loại riêng cho lành
		}
	>;

/**
 * Bị động buff chỉ số (có thể có hoặc không có điều kiện) - Ví dụ: Báo đen, Sát thủ
 */
type PermanentBuffPassive = SkillTypeDef<
	'permanent-buff',
	{
		/** Các stat được buff (Triển khai sau) */
		'stat-modifiers': {
			attribute: keyof ShootingStats | keyof SurvivalStats | keyof AttackPowerStats;
			value: ValueWithUnit;
		}[];

		/**
		 * Điều kiện để buff có hiệu lực (optional)
		 * - Ví dụ HP thấp hơn 40% mới tăng tốc
		 * - Xung quanh không có đồng đội
		 */
		conditions?: [];
	}
>;

// Phased passive skill (cho tank có nhiều phase)
type PhasedPassiveSkill<Phases extends number[]> = SkillTypeDef<
	'phased',
	{
		/** Phase ban đầu được dùng */
		'default-phase': Phases[number];

		/** Định nghĩa passive cho từng phase */
		'phases-definition': Record<Phases[number], SinglePassiveSkill>;
	}
>;

// Union type cho tất cả passive skills
type SinglePassiveSkill = EventTriggeredPassive | PeriodicPassive | PermanentBuffPassive;

// Entry type cho passive skill
export type PassiveSkillEntry<Phases extends number[]> = Phases extends []
	? SinglePassiveSkill
	: SinglePassiveSkill | PhasedPassiveSkill<Phases>;
```

dsl/example.ts:

```typescript
import { CreateContextImpactor, CreateNonContextImpactor } from './entity/skill/actions/create-attack.type-entities';

// Example
const skill_1: CreateNonContextImpactor = {
	action: '@create-entity',
	// Có thể trống
	// strategy: { type: 'direction', 'delta-angle': 0 },

	// Tầm, hướng bay, xuất phát từ đâu
	'limit-range': '100%',
	movement: { 'move-type': 'straight', speed: { value: '17.5u' } },
	from: 'self-pos',

	collider: {
		shape: { type: 'circle', size: { radius: 20 } },
		pierce: ['architecture', 'self', 'ally'],
	},

	visual: { sprite: { key: 'normal-attack' } },

	impact: {
		// interval: 0.5,
		actions: [
			{
				// Trúng đồng minh/bản thân giúp tăng 50% tốc chạy trong 2s
				'affected-faction': ['ally', 'self'],
				'target-effect': [
					{
						action: '@apply:modify-stat',
						'value-from': { attribute: 'movement-speed', value: '50%' },
						duration: 2,
					},
				],
			},
			{
				// Trúng mục tiêu không phải phe mình thì không cần khai báo 'affected-faction'
				'self-action': [
					{
						// Bản thân hồi HP
						action: '@apply:recover-hp',
						'value-from': { attribute: 'attack-power', value: '150%', of: 'self' },
					},
				],
				'target-effect': [
					{
						// Gây 150% tấn công
						action: '@apply:dealt-damage',
						'value-from': { attribute: 'attack-power', value: '175%', of: 'self' },
						'is-main-damage': true,
					},
					{
						// Kèm ST thực = 5% HP đã mất của mục tiêu
						action: '@apply:dealt-damage',
						'value-from': { attribute: 'lost-HP', of: 'target', value: '5%' },
						'damage-type': 'true',
						'text-delta-angle': 1,
					},
				],
			},
		],
		visual: { sprite: { key: 'normal-attack-impact' } },
	},
};

const skill_2: CreateContextImpactor = {
	action: '@create-entity',

	strategy: { type: 'targeting' },
	// strategy: { type: 'targeting', method: 'weakest' },

	from: 'mouse-pos',
	movement: { 'move-type': 'straight', speed: { value: '100%' } },
	impact: {
		actions: [
			{
				'self-action': [{ action: '@apply:change-phase', method: 'to-phase:3' }],
				'target-effect': [
					{
						action: '@apply:dealt-damage',
						'value-from': { attribute: 'attack-power', of: 'self', value: '150%' },
					},
				],
			},
		],
	},
	collider: { shape: { type: 'circle', size: { radius: 100 } } },
};
```

dsl/physic/collider.enums.ts:

```typescript
export type PierceableTarget = 'architecture' | 'self' | 'enemy' | 'ally' | 'non-tank' | 'projectile';
```

dsl/physic/collider.type-conponents.ts:

```typescript
import { PierceableTarget } from './collider.enums';
import { ColliderDeclaration } from './collider.type';

/**
 * Phát hiện va chạm
 */
export interface Collidable {
	/** Vùng va chạm để phát hiện đánh trúng */
	collider: {
		shape: ColliderDeclaration;

		/** Khai báo các rule xuyên thấu (nếu cần) */
		pierce?: PierceableTarget[] | 'all';

		/**
		 * - Thời gian đợi đến khi collider thực sự hoạt động
		 * - Đơn vị: s
		 * - Mặc định: 0s
		 * - Ví dụ: Space GCL hiện effect trước rồi mới giật
		 */
		'warm-up'?: number;
	};
}
```

dsl/physic/collider.type.ts:

```typescript
type ShapeName = 'rectangle' | 'circle';

interface Shape<Name extends ShapeName> {
	type: Name;
	size: Record<string, number>;
}

/**Hình chữ nhật */
export interface Rectangle extends Shape<'rectangle'> {
	size: {
		/** Chiều rộng (pixels) */
		width: number;

		/** Chiều cao (pixels) */
		height: number;
	};
}

/**Hình tròn hoặc hình quạt */
export interface Circle extends Shape<'circle'> {
	size: {
		/** Bán kính (pixels) */
		radius: number;

		/** Góc cung để tạo hình quạt (degrees). Không khai báo = hình tròn đầy đủ */
		'arc-angle'?: number;
	};
}

/**
 * Collider - Hình dạng dùng để phát hiện va chạm
 */
export type ColliderDeclaration = Rectangle | Circle;
```

dsl/physic/movement.enums.ts:

```typescript
import { TestKey } from '../.enums';
import { InheritDeclaration } from '../.types';

export type SpeedInheritAttribute = InheritDeclaration<'movement-speed' | 'flight-speed' | TestKey>;
export type MovementSpeedEnum = 160 | 165 | 170 | 175 | 180;
export type FlightSpeedEnum = 15 | 17.5;
```

dsl/physic/movement.type-components.ts:

```typescript
import { StraightMovement, TestMovement } from './movement.types';

export interface Movable {
	movement: StraightMovement | TestMovement;
}
```

dsl/physic/movement.types.ts:

```typescript
import { TestKey } from '../.enums';
import { ValueWithUnit } from '../.types';
import { FlightSpeedEnum, MovementSpeedEnum } from './movement.enums';

type MovementType = 'straight' | TestKey;

interface BaseMovement<T extends MovementType> {
	'move-type': T;
	speed: {
		value: ValueWithUnit<true, FlightSpeedEnum | MovementSpeedEnum | (number & {})>;

		/**Mặc định: `flight-speed` */
		of?: 'movement-speed' | 'flight-speed';
	};
}

// 2. Specific movement configs
export interface StraightMovement extends BaseMovement<'straight'> {}
export interface TestMovement extends BaseMovement<TestKey> {}
```

dsl/physic/position.enums.ts:

```typescript
export type PositionDeclaration = 'self-pos' | 'target-pos' | 'skill-pos' | 'mouse-pos';
```

dsl/physic/position.type-components.ts:

```typescript
import { PositionDeclaration } from './position.enums';

export interface RequireInitPositionMethod<T extends PositionDeclaration = PositionDeclaration> {
	/**Skill xuất phát từ đâu */
	from: T;
}
```

dsl/physic/range.enums.ts:

```typescript
export type RangeEnum = 1000 | 710 | 552 | 480 | 408 | 336 | 260 | 180 | 168;
```

dsl/physic/range.type-components.ts:

```typescript
import { ValueWithUnit } from '../.types';
import { RangeEnum } from './range.enums';

/** Tính chất có giới hạn phạm vi */
export interface LimitedDistance {
	/**
	 * - Với đơn vị là %, nó sẽ lấy `tầm bắn tank` * `% khai báo` / 100
	 * - Mặc định không khai báo sẽ kế thừa tầm đánh của tank, tức: `'100%'`
	 * - **Note**: Cẩn thận xử lý giá trị 0 và giá trị âm
	 */
	'limit-range'?: ValueWithUnit<true, RangeEnum | (number & {})>;
}

// Phạm vi 1000
const e1: LimitedDistance = { 'limit-range': '1000u +*1.5/s' };
```
